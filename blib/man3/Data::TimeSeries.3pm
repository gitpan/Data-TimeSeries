.\" Automatically generated by Pod::Man v1.34, Pod::Parser v1.13
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  | will give a
.\" real vertical bar.  \*(C+ will give a nicer C++.  Capital omega is used to
.\" do unbreakable dashes and therefore won't be available.  \*(C` and \*(C'
.\" expand to `' in nroff, nothing in troff, for use with C<>.
.tr \(*W-|\(bv\*(Tr
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "TimeSeries 3"
.TH TimeSeries 3 "2004-06-06" "perl v5.8.0" "User Contributed Perl Documentation"
.SH "NAME"
TimeSeries \- Perl extension for Manipulation of Time Series of numbers. TimeSeries supports all the periods of ChronoKey.
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  use TimeSeries;
.Ve
.PP
.Vb 4
\&  my $start =Data::TimeSeries::ChronoKey::new(Data::TimeSeries::ChronoKey::WEEK, "2004W48");
\&  my $stop =Data::TimeSeries::ChronoKey::new(Data::TimeSeries::ChronoKey::WEEK, "2005W02");
\&  my $timeSeries=Data::TimeSeries::new($start, 
\&            $stop,Data::TimeSeries::ChronoKey::WEEK,'{3,4,5,6,7,8,9,10}');
.Ve
.PP
.Vb 2
\&  $ts->addPoint(Data::TimeSeries::FIRST, 2);
\&  $ts->addPoint(Data::TimeSeries::LAST, 12);
.Ve
.PP
.Vb 1
\&  $ts->seriesOperate(sub {$total+=$_;});
.Ve
.PP
.Vb 2
\&  $ts->removePoint(Data::TimeSeries::LAST);
\&  $ts->removePoint(Data::TimeSeries::FIRST);
.Ve
.PP
.Vb 1
\&  $ts->seriesOperate(sub {$total+=$_;});
.Ve
.PP
.Vb 1
\&  $copy=$timeSeries->copy();
.Ve
.PP
.Vb 1
\&  $ts->normalize();
.Ve
.PP
.Vb 3
\&  my $rstart =Data::TimeSeries::ChronoKey::new(Data::TimeSeries::ChronoKey::WEEK, "2004W45");
\&  my $rstop =Data::TimeSeries::ChronoKey::new(Data::TimeSeries::ChronoKey::WEEK, "2004W51");
\&  $resized->resize($rstart, $rstop);
.Ve
.PP
.Vb 2
\&  $ts->stationize($station);
\&  $copy->remap(Data::TimeSeries::ChronoKey::DAY, Data::TimeSeries::SPREAD);
.Ve
.SH "LIMITATIONS/TODO"
.IX Header "LIMITATIONS/TODO"
TimeSeries assumes you are working with numeric data where there is a value for every target period.
.SH "METHODS"
.IX Header "METHODS"
.RE
.ie n .IP """new"""
.el .IP "\f(CWnew\fR"
.IX Item "new"
.Vb 1
\& $ts = Data::TimeSeries::new($start, $end, $period, $series);
.Ve
.PP
Creates and initalizes TimeSeries object.  \f(CW\*(C`new\*(C'\fR dies if parameters are not legal.  \f(CW$start\fR \- ChronoKey object. The position of the first element in the serines.  \f(CW$end\fR \- ChronoKey object. The position of the last element in the series.  \f(CW$period\fR \- A ChronoKey Period \f(CW$series\fR \- An array or a string that has the following format {1,2,4}. Should be of integer or floating point numbers.
.RE
.ie n .IP """start"""
.el .IP "\f(CWstart\fR"
.IX Item "start"
.Vb 2
\& $ck = $ts->start();
\& $ts->start($ck);
.Ve
.PP
The \f(CW\*(C`start\*(C'\fR method is the start position accesor. It can be used to get or set the start position.  Setting the start position directly is strongly discouraged. Use \f(CW\*(C`clip\*(C'\fR or \f(CW\*(C`resize\*(C'\fR instead.
.RE
.ie n .IP """end"""
.el .IP "\f(CWend\fR"
.IX Item "end"
.Vb 2
\& $ck = $ts->end();
\& $ts->end($ck);
.Ve
.PP
The \f(CW\*(C`end\*(C'\fR method is the end position accesor. It can be used to get or set the end position.  Setting the end position directly is strongly discouraged. Use \f(CW\*(C`clip\*(C'\fR or \f(CW\*(C`resize\*(C'\fR instead.
.RE
.ie n .IP """period"""
.el .IP "\f(CWperiod\fR"
.IX Item "period"
.Vb 2
\& $period = $ts->period();
\& $ts->period($period);
.Ve
.PP
The \f(CW\*(C`period\*(C'\fR method is the period of the time series. It can be used to get or set the  period.  Setting the end period directly is strongly discouraged. 
.RE
.ie n .IP """series"""
.el .IP "\f(CWseries\fR"
.IX Item "series"
.Vb 3
\& \e@series = $ts->series();
\& $ts->series(\e@series);
\& $ts->series("{1,2,3}");
.Ve
.PP
The \f(CW\*(C`series\*(C'\fR method is the series of the time series. It can be used to get or set the  series.  Setting the end series directly is somewhat discouraged. If you do set it, make sure it is the same length as the one you are replacing.
.RE
.ie n .IP """getCalcLen"""
.el .IP "\f(CWgetCalcLen\fR"
.IX Item "getCalcLen"
.Vb 1
\& $length = $ts->getCalcLen();
.Ve
.PP
The \f(CW\*(C`getCalcLen\*(C'\fR method is used to get the number of periods from the start and end positions (inclusive). It should be the same length as the series array.
.RE
.ie n .IP """addPoint"""
.el .IP "\f(CWaddPoint\fR"
.IX Item "addPoint"
.Vb 3
\& $ts->addPoint(TimeSeries::FIRST, 10.00);
\& $ts->addPoint(TimeSeries::LAST, 15.00);
\& $ts->addPoint($ck, 12.00);
.Ve
.PP
\&\f(CW\*(C`addPoint\*(C'\fR Method allows you to add a new point to the beginning or end of a timeseries.  Or you can add it somewhere within the series. The ChronoKey ($ck) must be within the existing range.  The series will be stretched forward to accomodate the new point.
.RE
.ie n .IP """removePoint"""
.el .IP "\f(CWremovePoint\fR"
.IX Item "removePoint"
.Vb 3
\& $ts->removePoint(TimeSeries::FIRST);
\& $ts->removePoint(TimeSeries::LAST);
\& $ts->removePoint($ck);
.Ve
.PP
The inverse of addPoint.  Allows you to remove the first, last or a cnter point.
.RE
.ie n .IP """getPoint"""
.el .IP "\f(CWgetPoint\fR"
.IX Item "getPoint"
.Vb 3
\& $ts->getPoint(TimeSeries::FIRST);
\& $ts->getPoint(TimeSeries::LAST);
\& $ts->removePoint($ck);
.Ve
.PP
\&\f(CW\*(C`getPoint\*(C'\fR gets the point at the specified position.
.RE
.ie n .IP """getLength"""
.el .IP "\f(CWgetLength\fR"
.IX Item "getLength"
.Vb 1
\& $len=$ts->getLength();
.Ve
.PP
\&\f(CW\*(C`getLength\*(C'\fR gets the length of the time series.
.RE
.ie n .IP """shift"""
.el .IP "\f(CWshift\fR"
.IX Item "shift"
.Vb 1
\& $ts->shift($units)
.Ve
.PP
\&\f(CW\*(C`shift\*(C'\fR shifts the time series by \f(CW$units\fR number of periods. 
.RE
.ie n .IP """seasonalize"""
.el .IP "\f(CWseasonalize\fR"
.IX Item "seasonalize"
.Vb 1
\& $ts->seasonalize()
.Ve
.RE
.ie n .IP """normalize"""
.el .IP "\f(CWnormalize\fR"
.IX Item "normalize"
.Vb 1
\& $ts->normalize()
.Ve
.PP
Takes the time series and makes it sum to 1.
.RE
.ie n .IP """resize"""
.el .IP "\f(CWresize\fR"
.IX Item "resize"
.Vb 1
\& $ts->resize($start, $end)
.Ve
.PP
Stretches or shrinks the time series to fit the \f(CW$start\fR and \f(CW$end\fR chronokeys.  Linear Interpolation is used to build missing values.
.RE
.ie n .IP """seriesOperate"""
.el .IP "\f(CWseriesOperate\fR"
.IX Item "seriesOperate"
.Vb 1
\& $ts->seriesOperate(sub {$_*=20;})
.Ve
.PP
Runs an operation on every item in the series.
.RE
.ie n .IP """clip"""
.el .IP "\f(CWclip\fR"
.IX Item "clip"
.Vb 1
\& $ts->clip($startCK,$endCK);
.Ve
.PP
Cuts down the time series to the specified start and end positions.
.RE
.ie n .IP """copy"""
.el .IP "\f(CWcopy\fR"
.IX Item "copy"
.Vb 1
\& $ts2=$ts->copy();
.Ve
.PP
Creates a copy of the time series.
.PP
Runs an operation on every item in the series.
.PP
\&\s-1TODO\s0
=item \f(CW\*(C`regression\*(C'\fR
.PP
($slope, \f(CW$constant\fR)=$ts\->\fIregression()\fR;
.PP
.Vb 1
\& Runs a regression algorithm on a time series.
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
.Vb 1
\&  Data::TimeSeries allows easy manipulation of timeseries related data.
.Ve
.Sh "\s-1EXPORT\s0"
.IX Subsection "EXPORT"
None by default.
.SH "AUTHOR"
.IX Header "AUTHOR"
ts(at)atlantageek.com
.SH "SEE ALSO"
.IX Header "SEE ALSO"
perl.
